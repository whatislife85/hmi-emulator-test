<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8">

<meta name="viewport" content="width=device-width,
    user-scalable=no, initial-scale=1, maximum-scale=1, user-scalable=0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<style type="text/css">
body { margin: 0; padding: 0; background: #000000;}
canvas { display: block; margin: 0 auto; background: #444444; }
</style>

</head>

<body>

<canvas> </canvas>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"> </script>
<script type="text/javascript" src="DoasMenu.txt"></script>
<script>
// namespace our game
var HMI = {

    // set up some initial values
    WIDTH: 800,
    HEIGHT:  480,
    // we'll set the rest of these
    // in the init function
    RATIO:  null,
    currentWidth:  null,
    currentHeight:  null,
    canvas: null,
    ctx:  null,
    // let's keep track of scale
    // along with all initial declarations
    // at the start of the program
    scale:  1,
    // the position of the canvas
    // in relation to the screen
    offset: {top: 0, left: 0},

    menuTree: DoasMenu.MenuItems[0],
    menuPath: [],

    init: function() {

        // the proportion of width to height
        HMI.RATIO = HMI.WIDTH / HMI.HEIGHT;
        // these will change when the screen is resized
        HMI.currentWidth = HMI.WIDTH;
        HMI.currentHeight = HMI.HEIGHT;
        // this is our canvas element
        HMI.canvas = document.getElementsByTagName('canvas')[0];
        // setting this is important
        // otherwise the browser will
        // default to 320 x 200
        HMI.canvas.width = HMI.WIDTH;
        HMI.canvas.height = HMI.HEIGHT;
        // the canvas context enables us to
        // interact with the canvas api
        HMI.ctx = HMI.canvas.getContext('2d');

        // we're ready to resize
        HMI.resize();

        HMI.Draw.drawHmi();
        HMI.Draw.text('IDLE', (8.5*HMI.WIDTH/20), HMI.HEIGHT/2, 54, '#000');

        // listen for clicks
        window.addEventListener('click', function(e) {
            e.preventDefault();
            HMI.Input.set([e]);
        }, false);

        // listen for touches
        window.addEventListener('touchstart', function(e) {
            //e.preventDefault();
            // the event object has an array
            // named touches (for multi-touch);
            HMI.Input.set(e.touches);
        }, false);
        window.addEventListener('touchmove', function(e) {
            // we're not interested in this,
            // but prevent default behaviour
            // so the screen doesn't scroll
            // or zoom
            //e.preventDefault();
        }, false);
        window.addEventListener('touchend', function(e) {
            // as above
            //e.preventDefault();
        }, false);
    },

    resize: function() {

        HMI.currentHeight = window.innerHeight;
        // resize the width in proportion
        // to the new height
        HMI.currentWidth = HMI.currentHeight * HMI.RATIO;

        // this will create some extra space on the
        // page, allowing us to scroll past
        // the address bar, thus hiding it.
        if (HMI.android || HMI.ios) {
            document.body.style.height = (window.innerHeight + 50) + 'px';
        }

        // set the new canvas style width and height
        // note: our canvas is still 320 x 480, but
        // we're essentially scaling it with CSS
        HMI.canvas.style.width = HMI.currentWidth + 'px';
        HMI.canvas.style.height = HMI.currentHeight + 'px';
        HMI.scale = HMI.currentWidth / HMI.WIDTH;
        HMI.offset.top = HMI.canvas.offsetTop;
        HMI.offset.left = HMI.canvas.offsetLeft;

        // we need to sniff out Android and iOS
        // so that we can hide the address bar in
        // our resize function
        HMI.ua = navigator.userAgent.toLowerCase();
        HMI.android = HMI.ua.indexOf('android') > -1 ? true : false;
        HMI.ios = ( HMI.ua.indexOf('iphone') > -1 || HMI.ua.indexOf('ipad') > -1 || HMI.ua.indexOf('ipod') > -1 ) ? true : false;

        // this will create some extra space on the
        // page, enabling us to scroll past
        // the address bar, thus hiding it.
        if (HMI.android || HMI.ios) {
            document.body.style.height = (window.innerHeight + 50) + 'px';
        }

        // we use a timeout here because some mobile
        // browsers don't fire if there is not
        // a short delay
        window.setTimeout(function() {
                window.scrollTo(0,1);
        }, 1);
    }
};

// FUN FUNCTIONS BEGIN //////////////////////////
HMI.currentMenu = HMI.menuTree
btnXY = [
  [(HMI.WIDTH)/8, 3*(HMI.HEIGHT)/8], 
  [(HMI.WIDTH/8), 5*(HMI.HEIGHT/8)], 
  [7*(HMI.WIDTH/8), 3*(HMI.HEIGHT/8)], 
  [7*(HMI.WIDTH/8), 5*(HMI.HEIGHT/8)]
];
btnR = HMI.WIDTH/20;

function upBtnPressed() {
  console.log("up")
}
function downBtnPressed() {
  console.log("down")
}
function backBtnPressed() {
  console.log("back")
}
function enterBtnPressed() {
  console.log("enter")

  //HMI.Draw.drawHmi();
  //HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 0.97*HMI.HEIGHT/3, 34, '#000');
  //HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 1.27*HMI.HEIGHT/3, 34, '#000');
  //HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 1.57*HMI.HEIGHT/3, 34, '#000');
  //HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 1.87*HMI.HEIGHT/3, 34, '#000');
  //HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 2.17*HMI.HEIGHT/3, 34, '#000');
  //HMI.currentMenu = HMI.currentMenu.MenuItems[0];
  //console.log(HMI.currentMenu);
}

function topBtnsPressed() {
  HMI.Draw.drawHmi();
  HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 0.97*HMI.HEIGHT/3, 34, '#000');
  HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 1.27*HMI.HEIGHT/3, 34, '#000');
  HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 1.57*HMI.HEIGHT/3, 34, '#000');
  HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 1.87*HMI.HEIGHT/3, 34, '#000');
  HMI.Draw.text(HMI.currentMenu.Text, (HMI.WIDTH/2)-(9.5*String(HMI.currentMenu.Text).length), 2.17*HMI.HEIGHT/3, 34, '#000');
  //HMI.currentMenu = HMI.currentMenu.MenuItems[0];
  //console.log(HMI.currentMenu);
  console.log("top buttons pressed");
}

function btnLogic(btnsPressed) {
  if(btnsPressed.length == 1) {
    switch(btnsPressed[0]) {
      case 0:
        upBtnPressed();
        break;
      case 1:
        downBtnPressed();
        break;
      case 2:
        backBtnPressed();
        break;
      case 3:
        enterBtnPressed();
        break;
    }
  }
   else if((btnsPressed.length == 2 && btnsPressed.includes(0) && btnsPressed.includes(2))) {
      topBtnsPressed();
   }
}

// FUN FUNCTIONS END ///////////////////////////

// abstracts various canvas operations into
// standalone functions
HMI.Draw = {

    clear: function() {
        HMI.ctx.clearRect(0, 0, HMI.WIDTH, HMI.HEIGHT);
    },

    rect: function(x, y, w, h, col) {
        HMI.ctx.fillStyle = col;
        HMI.ctx.fillRect(x, y, w, h);
    },

    circle: function(x, y, r, col) {
        HMI.ctx.fillStyle = col;
        HMI.ctx.beginPath();
        HMI.ctx.arc(x + 5, y + 5, r, 0,  Math.PI * 2, true);
        HMI.ctx.closePath();
        HMI.ctx.fill();
    },

    text: function(string, x, y, size, col) {
        HMI.ctx.font = 'bold '+size+'px Monospace';
        HMI.ctx.fillStyle = col;
        HMI.ctx.fillText(string, x, y);
    },

    drawHmi: function() {
        HMI.Draw.clear();
        HMI.Draw.rect(HMI.WIDTH/4, HMI.HEIGHT/4, HMI.WIDTH/2, HMI.HEIGHT/2, '#D3D3D3');
        HMI.Draw.circle(btnXY[0][0], btnXY[0][1], btnR, 'black');
        HMI.Draw.circle(btnXY[1][0], btnXY[1][1], btnR, 'black');
        HMI.Draw.circle(btnXY[2][0], btnXY[2][1], btnR, 'black');
        HMI.Draw.circle(btnXY[3][0], btnXY[3][1], btnR, 'black');
        HMI.Draw.text('CaptiveAire HMI Emulator Test', HMI.WIDTH/2, 4*HMI.HEIGHT/5, 14, '#000');
    }

};

// + add this at the bottom of your code,
// before the window.addEventListeners
HMI.Input = {
    x: 0,
    y: 0,
    tapped :false,

    btnsPressed: [],
    set: function(data) {
      //console.log(data);
      for(j = 0; j < data.length; j++) {
        this.x = (data[j].pageX - HMI.offset.left) / HMI.scale;
        this.y = (data[j].pageY - HMI.offset.top) / HMI.scale;
        this.tapped = true;

        for(i = 0; i < btnXY.length; i++) {
          if (Math.sqrt((this.x-btnXY[i][0])**2 + (this.y-btnXY[i][1])**2) < btnR) {
            this.btnsPressed.push(i);
          }
        }
      }
      btnLogic(this.btnsPressed);
      this.btnsPressed = [];
    }
};

window.addEventListener('load', HMI.init, false);
window.addEventListener('resize', HMI.resize, false);

</script>

</body>
</html>